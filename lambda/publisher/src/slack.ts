/**
 * Slack Webhook Client
 *
 * é€±æ¬¡ãƒ¬ãƒãƒ¼ãƒˆã‚’Slackã«é€ä¿¡
 */

import https from 'https';

export interface SlackConfig {
  webhookUrl: string;
}

export interface SlackReportData {
  title: string;
  period_start: string;
  period_end: string;
  summary: {
    total_commits: number;
    total_additions: number;
    total_deletions: number;
    active_repos: number;
  };
  repositories: Array<{
    name: string;
    commits: number;
  }>;
}

/**
 * Slackã«ãƒ¬ãƒãƒ¼ãƒˆé€ä¿¡
 */
export async function publishToSlack(
  config: SlackConfig,
  report: SlackReportData
): Promise<void> {
  console.log('ğŸ“¤ Slacké€ä¿¡ä¸­...');

  const message = buildSlackMessage(report);

  return new Promise((resolve, reject) => {
    const url = new URL(config.webhookUrl);

    const options = {
      hostname: url.hostname,
      path: url.pathname,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    const req = https.request(options, (res) => {
      let data = '';

      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        if (res.statusCode === 200) {
          console.log('âœ… Slacké€ä¿¡æˆåŠŸ');
          resolve();
        } else {
          console.error(`âŒ Slacké€ä¿¡å¤±æ•—: ${res.statusCode}`);
          console.error(`Response: ${data}`);
          reject(new Error(`Slack API error: ${res.statusCode}`));
        }
      });
    });

    req.on('error', (error) => {
      console.error('âŒ Slackãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      reject(error);
    });

    req.write(JSON.stringify(message));
    req.end();
  });
}

/**
 * Slackãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ§‹ç¯‰
 */
function buildSlackMessage(report: SlackReportData): any {
  const topRepos = report.repositories
    .slice(0, 5)
    .map((r, i) => `${i + 1}. *${r.name}*: ${r.commits} commits`)
    .join('\n');

  return {
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `ğŸ“Š ${report.title}`,
          emoji: true,
        },
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*æœŸé–“*: ${report.period_start} ã€œ ${report.period_end}`,
        },
      },
      {
        type: 'divider',
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*ç·ã‚³ãƒŸãƒƒãƒˆæ•°*\n${report.summary.total_commits}`,
          },
          {
            type: 'mrkdwn',
            text: `*ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒªãƒã‚¸ãƒˆãƒª*\n${report.summary.active_repos}`,
          },
          {
            type: 'mrkdwn',
            text: `*è¿½åŠ è¡Œæ•°*\n+${report.summary.total_additions.toLocaleString()}`,
          },
          {
            type: 'mrkdwn',
            text: `*å‰Šé™¤è¡Œæ•°*\n-${report.summary.total_deletions.toLocaleString()}`,
          },
        ],
      },
      {
        type: 'divider',
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*ğŸ“¦ Top 5 ãƒªãƒã‚¸ãƒˆãƒª*\n${topRepos}`,
        },
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: 'ğŸ¤– Generated by GitHub Activity Aggregator',
          },
        ],
      },
    ],
  };
}
